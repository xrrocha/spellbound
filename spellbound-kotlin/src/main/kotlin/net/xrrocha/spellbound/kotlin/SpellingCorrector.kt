package net.xrrocha.spellbound.kotlin

import kotlinx.coroutines.experimental.CommonPool
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking
import net.xrrocha.spellbound.kotlin.Edits.wordSplits

/**
 * A dictionary-based spelling corrector.
 *
 * This corrector implements Peter Norvig's
 * [spelling corrector algorithm](http://norvig.com/spell-correct.html).
 *
 * @property dictionary the `Map<String, Integer>` dictionary mapping words to ranking
 * @constructor Creates an instance backed by the given `dictionary`
 */
class SpellingCorrector(private val dictionary: Map<String, Int>) {

  init {
    if (dictionary.isEmpty()) {
      throw IllegalArgumentException("Dictionary cannot be null")
    }
  }

  /**
   * Return all dictionary words in the generated by `edits1` or `edits2` functions.
   *
   * @property word The word to be checked for correctness (i.e., appearance in the dictionary)
   *             or for correction suggestions as generated by edits1` or `edits2`
   */
  fun getCorrections(word: String): Iterable<String>? {

    val normalizedWord = word.normalize()

    // Dictionary words generate no suggestions;
    // this is expressed as a `null` word set
    if (dictionary.containsKey(normalizedWord)) {
      return null
    }

    /**
     * Extension function for type `Iterable<String>` that:
     * - suppresses any duplicates,
     * - filters out any word not appearing in the given
     *   `dictionary` and
     * - orders words by their dictionary-given rank
     * @property dictionary The `Map<String, Int>` dictionary
     *        providing membership testing and word ranking
     * @return The curated resulting `Iterable<String>`
     */
    fun Iterable<String>.known(): Iterable<String> =
        this
            .distinct()
            .filter { dictionary.containsKey(it) }
            .map { Pair(it, dictionary[it]!!) }
            .sortedBy { -it.second }
            .map { it.first }

    // Attempt to reconstitute one or more dictionary words
    // from the typo assuming it comes from a single error
    val corrections1 = edits1(normalizedWord).known()
    return if (!corrections1.none()) corrections1
    else {
      // Failing the above, attempt to reconstitute one or
      // more dictionary words from the typo assuming it
      // comes from two errors. Return `emptyList()` to
      // indicate the word *is* a typo but no suggestions
      // were found for it
      edits2(normalizedWord).known()
    }
  }

  /**
   * Attempt to reconstitute one or more words from the given `typo`.
   * Failure to produce suggestions results in an empty `Iterable<String>`.
   * @property typo the non-dictionary word to use in searching for
   *        similar dictionary words
   * @return The (possibly empty) `Iterable<String>` of all
   *         dictionary words gathered from the given `typo`
   */
  fun edits1(typo: String): Iterable<String> =
      Edits.ALL_EDITS.parFlatMap { it(typo.wordSplits()) }

  /**
   * Attempt to reconstitute one or more words from the word splits
   * originated in the given `typo`. Failure to produce suggestions
   * results in an empty `Iterable<String>`
   * @property typo the non-dictionary word to use in searching for
   *        similar dictionary words
   * @return The (possibly empty) `Iterable<String>` of all
   *         dictionary words gathered from the given `typo`
   *         to the word splits resulting from applying `edit1`
   *         to the typo.
   */
  fun edits2(typo: String): Iterable<String> =
  // Try to find dictionary words in the (failed) result of
  // `edit1` by applying all four edits to each edit1 word
      edits1(typo).flatMap { edits1(it) }

  /**
   * The `SpellingCorrector` companion object.
   *
   * This object contains:
   * - A `normalize` function that trims alpha-only words
   *   and makes them all-lowercase. Non-alpha words result
   *   in an `IllegalArgumentException`
   * - A `pack` extension function for type `Iterable<String>`
   *   so that `edit1` and `edit2` results are normalized by
   *   suppressing duplicates, ensuring they actually occur in
   *   a given `dictionary` and ordering them by ranking (i.e.,
   *   word-level probability of occurrence)
   * - A `parFlatMap` extension function for type `Iterable<A>`
   *   that applies a `flatMap` operation in parallel for all
   *   items in the set
   */
  companion object {

    /**
     * The alpha-only regular expression.
     */
    private val Alphabetic = "^[a-z]+$".toRegex()

    fun String.isAlphabetic() = Alphabetic.containsMatchIn(this)

    /**
     * Normalize a given alpha-only `word` by trimming any
     * surrounding space and converting the result to
     * all-lowercase.
     * @property word the word to be normalized
     * @return the normalized word
     * @throws IllegalArgumentException if the word is not
     *         entirely Alphabetic
     */
    fun String.normalize(): String {
      val normalizedWord = this.trim().toLowerCase()
      return if (normalizedWord.isAlphabetic()) normalizedWord
      else throw IllegalArgumentException("Non-alpha word: $normalizedWord")
    }

    /**
     * Run the given (flat) mapper in parallel via coroutines.
     *
     * Akin to Java's Collection.parallelStream() also taking
     * as argument the given (nested `Iterable`-yielding)
     * function.
     * @param A The generic type of the input `Iterable`
     * @param B The generic type of the output `Iterable`
     * @property mapper the nested `Iterable`-yielding function
     *           to apply.
     * @return The result of applying and then flattening the
     *         given `mapper`
     */
    // Run flattening mapper in parallel via coroutines.
    // Akin to Java's Collection.parallelStream() followed by flatMap()
    fun <A, B> Iterable<A>.parFlatMap(mapper: suspend (A) -> Iterable<B>): Iterable<B> = runBlocking {
      map { async(CommonPool) { mapper(it) } }.flatMap { it.await() }
    }
  }
}