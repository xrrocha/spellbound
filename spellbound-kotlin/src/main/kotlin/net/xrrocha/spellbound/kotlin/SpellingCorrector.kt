package net.xrrocha.spellbound.kotlin

import kotlinx.coroutines.experimental.CommonPool
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking

/**
 * A dictionary-based spelling corrector.
 *
 * This corrector implements Peter Norvig's
 * [spelling corrector algorithm](http://norvig.com/spell-correct.html).
 *
 * @property dictionary the `Map<String, Integer>` dictionary mapping words to ranking
 * @constructor Creates an instance backed by the given `dictionary`
 */
class SpellingCorrector(private val dictionary: Map<String, Int>) {

    /**
     * Return all dictionary words in the generated by `edits1` or `edits2` functions.
     *
     * @property word The word to be checked for correctness (i.e., appearance in the dictionary)
     *             or for correction suggestions as generated by edits1` or `edits2`
     */
    fun getCorrections(word: String): Iterable<String>? {

        val normalizedWord = normalize(word)

        // Dictionary words generate no suggestions;
        // this is expressed as a `null` word set
        if (dictionary.containsKey(normalizedWord)) {
            return null
        }

        // Attempt to reconstitute one or more dictionary words
        // from the typo assuming it comes from a single error
        val corrections1 = edits1(normalizedWord)
        return if (corrections1.iterator().hasNext()) corrections1
        else {
            // Failing the above, attempt to reconstitute one or
            // more dictionary words from the typo assuming it
            // comes from two errors. Return `emptyList()` to
            // indicate the word *is* a typo but no suggestions
            // were found for it
            val corrections2 = edits2(normalizedWord)
            if (corrections2.iterator().hasNext()) corrections2 else emptyList()
        }
    }

    /**
     * Attempt to reconstitute one or more words from the given `typo`.
     * Failure to produce suggestions results in an empty `Iterable<String>`.
     * @property typo the non-dictionary word to use in searching for
     *        similar dictionary words
     * @return The (possibly empty) `Iterable<String>` of all
     *         dictionary words gathered from the given `typo`
     */
    fun edits1(typo: String): Iterable<String> {
        // Collect typo's word splits
        val wordSplits = Edits.wordSplits(typo)
        // Exercise all four edits in parallel and coalesce (*pack*)
        // the results
        return Edits.ALL_EDITS
                .pFlatMap { it(wordSplits) }
                .pack(dictionary)
    }

    /**
     * Attempt to reconstitute one or more words from the word splits
     * originated in the given `typo`. Failure to produce suggestions
     * results in an empty `Iterable<String>`
     * @property typo the non-dictionary word to use in searching for
     *        similar dictionary words
     * @return The (possibly empty) `Iterable<String>` of all
     *         dictionary words gathered from the given `typo`
     *         to the word splits resulting from applying `edit1`
     *         to the typo.
     */
    fun edits2(typo: String): Iterable<String> =
            // Try to find dictionary words in the (failed) result
            // of `edit1` by applying, in parallel, all four edits
            // to each edit and coalescing results (with *pack*)
            edits1(typo)
                    .pFlatMap { edits1(it) }
                    .pack(dictionary)

    /**
     * The `SpellingCorrector` companion object.
     *
     * This object contains:
     * - A `normalize` function that trims alpha-only words
     *   and makes them all-lowercase. Non-alpha words result
     *   in an `IllegalArgumentException`
     * - A `pack` extension function for type `Iterable<String>`
     *   so that `edit1` and `edit2` results are normalized by
     *   suppressing duplicates, ensuring they actually occur in
     *   a given `dictionary` and ordering them by ranking (i.e.,
     *   word-level probability of occurrence)
     * - A `pFlatMap` extension function for type `Iterable<A>`
     *   that applies a `flatMap` operation in parallel for all
     *   items in the set
     */
    companion object {

        /**
         * The alpha-only regular expression.
         */
        private val alphabetic = "^[a-z]+$".toRegex()

        /**
         * Normalize a given alpha-only `word` by trimming any
         * surrounding space and converting the result to
         * all-lowercase.
         * @property word the word to be normalized
         * @return the normalized word
         * @throws IllegalArgumentException if the word is not
         *         entirely alphabetic
         */
        fun normalize(word: String): String {
            val normalizedWord = word.trim().toLowerCase()
            return if (alphabetic.containsMatchIn(normalizedWord)) normalizedWord
            else throw IllegalArgumentException("Non-alpha word: $normalizedWord")
        }

        /**
         * Extension function for type `Iterable<String>` that:
         * - suppresses any duplicates,
         * - filters out any word not appearing in the given
         *   `dictionary` and
         * - orders words by their dictionary-given rank
         * @property dictionary The `Map<String, Int>` dictionary
         *        providing membership testing and word ranking
         * @return The curated resulting `Iterable<String>`
         */
        fun Iterable<String>.pack(dictionary: Map<String, Int>): Iterable<String> =
                this
                        .distinct()
                        .filter { dictionary.containsKey(it) }
                        .map { Pair(it, dictionary[it]!!) }
                        .sortedBy { it.second }
                        .map { it.first }

        /**
         * Run the given (flat) mapper in parallel via coroutines.
         *
         * Akin to Java's Collection.parallelStream() also taking
         * as argument the given (nested `Iterable`-yielding)
         * function.
         * @param A The generic type of the input `Iterable`
         * @param B The generic type of the output `Iterable`
         * @property mapper the nested `Iterable`-yielding function
         *           to apply.
         * @return The result of applying and then flattening the
         *         given `mapper`
         */
        // Run flattening mapper in parallel via coroutines.
        // Akin to Java's Collection.parallelStream() followed by flatMap()
        fun <A, B> Iterable<A>.pFlatMap(mapper: suspend (A) -> Iterable<B>): Iterable<B> = runBlocking {
            map { async(CommonPool) { mapper(it) } }.flatMap { it.await() }
        }
    }
}